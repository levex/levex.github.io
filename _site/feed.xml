<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.0">Jekyll</generator><link href="http://kernelstuff.org/feed.xml" rel="self" type="application/atom+xml" /><link href="http://kernelstuff.org/" rel="alternate" type="text/html" /><updated>2018-04-01T19:36:55+02:00</updated><id>http://kernelstuff.org/</id><title type="html">Random Kernel Stuff</title><subtitle>Low-level adventures, kernel engineering, OSDev, Haskell and tea.
</subtitle><author><name>Levente Kurusa</name></author><entry><title type="html">x86 ISA Extensions part I: MMX</title><link href="http://kernelstuff.org/post/x86-extensions/2018/03/31/x86-extensions-mmx.html" rel="alternate" type="text/html" title="x86 ISA Extensions part I: MMX" /><published>2018-03-31T20:28:00+02:00</published><updated>2018-03-31T20:28:00+02:00</updated><id>http://kernelstuff.org/post/x86-extensions/2018/03/31/x86-extensions-mmx</id><content type="html" xml:base="http://kernelstuff.org/post/x86-extensions/2018/03/31/x86-extensions-mmx.html">&lt;p&gt;Welcome to this series about instruction set extensions to the x86 architecture. X86 is a computer architecture that has evolved loads over the years and there have been many extensions to the original instruction set (including 64-bit “long” mode). Over the course of a few blog posts, we explore these extensions and the reasoning behind their existence.&lt;/p&gt;

&lt;p&gt;So, the first extension I’d like to talk about is the MMX extension originally introduced with the Pentium P5 family of Intel processors in the late 1990s. Let’s dive in!&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h2 id=&quot;do-you-have-mmx&quot;&gt;Do you have MMX?&lt;/h2&gt;

&lt;p&gt;As with every instruction set extension, there is a possibility that the CPU of your system does not support it. The chances are pretty slim with MMX given that it has been around for a long while, but just to be sure follow these instructions:&lt;/p&gt;

&lt;p&gt;On Linux:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat /proc/cpuinfo | grep -wq mmx &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;MMX available&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;MMX not available&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;On OS X/macOS:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sysctl machdep.cpu.features | grep -wq MMX &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;MMX available&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;MMX not available&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Alternatively, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;CPUID&lt;/code&gt; instruction to figure whether your CPU supports MMX (as indicated by Leaf 1, Bit 23):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly_x86&quot;&gt;.text
.globl _is_mmx_available
_is_mmx_available:
    pushq   %rbx

    movq    $1, %rax
    cpuid
    movq    %rdx, %rax
    shrq    $23, %rax
    andq    $1, %rax

    popq    %rbx
    ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;technical-details&quot;&gt;Technical details&lt;/h2&gt;

&lt;p&gt;Interestingly, MMX does not introduce new registers, but instead opts to introduce aliases for the 80-bit x87 FPU registers’ bottom 64 bits. These are called &lt;code class=&quot;highlighter-rouge&quot;&gt;%mmx0, %mmx1, ..., %mmx7&lt;/code&gt;. Since these are only aliases and not real registers, it is immediately obvious that the registers cannot be used while an FPU operation is taking place. Since FPU registers are 80-bit long and MMX “registers” are 64-bit it’s important to note where in those FPU registers are the MMX registers: they form the 64-bit mantissa of the original FPU register, and the remaining 16 bits are all set to 1. This is useful, since it means the FPU can recognize the SIMD data in the registers as NaN or infinities and of course, software can distinguish between the two types of data as well.&lt;/p&gt;

&lt;p&gt;But why did Intel choose to use aliases instead of adding new registers? They wanted to be trivially compatible with existing operating systems’ context switching code which already knew how to save and restore the FPU registers and now by the virtue of aliasing, it also supports saving and restoring the MMX registers.&lt;/p&gt;

&lt;p&gt;The main selling point of MMX is the ability to pack multiple values into the MMX registers and do operations on each individual value separately, in one instruction, hence the SIMD (&lt;em&gt;Single Instruction Multiple Data&lt;/em&gt;) nature. It is possible to have eight, one-byte values in a single MMX register:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%mmx0 = 
+------+------+------+------+------+------+------+------+
|   7  |   6  |  5   |   4  |   3  |   2  |  1   |   0  | Byte
+------+------+------+------+------+------+------+------+
| 0x11 | 0x22 | 0x33 | 0x44 | 0x55 | 0x66 | 0x77 | 0x88 | Values
+------+------+------+------+------+------+------+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or it is possible to have two, 4-byte long values in the register:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%mmx1 = 
+------+------+------+------+------+------+------+------+
|   7  |   6  |  5   |   4  |   3  |   2  |  1   |   0  | Byte
+------+------+------+------+------+------+------+------+
|          0xcc77ff88       |          0x11223344       | Values
+------+------+------+------+------+------+------+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Similarly, it is possible to have four, two-byte values as well.&lt;/p&gt;

&lt;h2 id=&quot;new-instructions&quot;&gt;New instructions&lt;/h2&gt;

&lt;p&gt;An example usage of the new instructions can be found in the &lt;a href=&quot;https://github.com/levex/x86-isa-extensions/tree/master/mmx&quot;&gt;GitHub Repo&lt;/a&gt; of this series. It simply adds two times four, one-byte values together.&lt;/p&gt;

&lt;p&gt;Some simple instructions introduced by MMX can be seen in the following table:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Instruction&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;emms&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Reset the MMX state&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;paddb&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;paddw&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;paddd&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;paddq&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Add two groups of bytes, words, double-words, or quad-words&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;psub&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;psubw&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;psubd&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;psubq&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Substract two groups of bytes, words, double-words, or quad-words&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pcmpeqb&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;pcmpeqw&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;pcmpeqd&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;pcmpeqq&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Compare two groups of bytes, words, double-words, or quad-words for equality&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A more complex instruction would be the &lt;code class=&quot;highlighter-rouge&quot;&gt;unpck&lt;/code&gt; class of instructions that allow interleaving data from two groups of data by doubling the group size:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;punpckhbw&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;punpckhwd&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;punpckhdq&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;punpcklbw&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;punpcklwd&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;punpckldq&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The interleave done by &lt;code class=&quot;highlighter-rouge&quot;&gt;punpckhbw&lt;/code&gt; is best described by the following graphic, however let us decompose this instruction into a more readable form:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; =&amp;gt; packed&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unpck&lt;/code&gt; =&amp;gt; unpack&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; =&amp;gt; high order&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; =&amp;gt; from bytes&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; =&amp;gt; to words&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Putting it all together this seems to imply that this instruction interleaves the higher order part (top half) of a group of bytes into a group of words in the destination register. This can be still quite confusing, so here’s a graphic that explains it a bit better I’d hope:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                                                                                               
             Source Register                          Destination Register                     
                                                                                               
+----+----+----+----+----+----+----+----+   +----+----+----+----+----+----+----+----+          
| Y7 | Y6 | Y5 | Y4 | Y3 | Y2 | Y1 | Y0 |   | X7 | X6 | X5 | X4 | X3 | X2 | X1 | X0 |          
+----+----+----+----+----+----+----+----+   +----+----+----+----+----+----+----+----+          
   |    |    |    |                            |    |    |    |                                
   |    |    |    |                            |    |    |    |                                
   |    |    |    |                            |    |    |    |                                
   |    |    |    |           +---------+------+--+-+----+  +-+                                
   |    |    |    |           |         |         |         |                                  
   |    |    |    |           |         |         |         |                                  
   |    |    |    |           v         v         v         v                                  
   |    |    |    |   +----+----+----+----+----+----+----+----+                                
   |    |    |    |   | Y7 | X7 | Y6 | X6 | Y5 | X5 | Y4 | X4 | Destination Register           
   |    |    |    |   +----+----+----+----+----+----+----+----+                                
   |    |    |    |      ^         ^         ^         ^                                       
   |    |    |    |      |         |         |         |                                       
   +----+----+----+------+---------+---------+---------+                                                                                                         
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;successor&quot;&gt;Successor&lt;/h2&gt;

&lt;p&gt;AMD shortly caught on with its own extension to Intel’s MMX, named “3DNow!” which didn’t really see much success, but we will cover it in a next installment of this series.&lt;/p&gt;

&lt;p&gt;Other successors include an “Extended MMX” from Intel, and SSE (&lt;em&gt;Streaming SIMD Extensions&lt;/em&gt;). Extended MMX is of particular interest because it introduces several new, interesting instructions to MMX:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Instruction&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;movntq&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Move a quad-word (64-bit value) to memory and   do not put it in the cache (bypass the cache)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pextrw&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Extract a (specified) word from a group&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pinsrw&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Insert a word into a group at a specified location&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pmovmskb&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Create an 8-bit integer from the most significant bits of eight one-byte values in an MMX register&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pavgb&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;pavgw&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Averages the (unsigned) bytes or words&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope you enjoyed this part and will enjoy the rest of the series. I would be highly appreciative of any feedback you may have. If you have an example of a use-case for MMX, it would be nice to hear from you and of course, feel free to submit a pull request to the repo linked above.&lt;/p&gt;</content><author><name>Levente Kurusa</name></author><summary type="html">Welcome to this series about instruction set extensions to the x86 architecture. X86 is a computer architecture that has evolved loads over the years and there have been many extensions to the original instruction set (including 64-bit “long” mode). Over the course of a few blog posts, we explore these extensions and the reasoning behind their existence. So, the first extension I’d like to talk about is the MMX extension originally introduced with the Pentium P5 family of Intel processors in the late 1990s. Let’s dive in!</summary></entry><entry><title type="html">Paper review: Shadow Kernels</title><link href="http://kernelstuff.org/kernel/paper-reviews/2017/08/20/shadow-kernels.html" rel="alternate" type="text/html" title="Paper review: Shadow Kernels" /><published>2017-08-20T14:00:00+02:00</published><updated>2017-08-20T14:00:00+02:00</updated><id>http://kernelstuff.org/kernel/paper-reviews/2017/08/20/shadow-kernels</id><content type="html" xml:base="http://kernelstuff.org/kernel/paper-reviews/2017/08/20/shadow-kernels.html">&lt;h1 id=&quot;shadow-kernels-a-general-mechanism-for-kernel-specialization-in-existing-operating-systems&quot;&gt;Shadow Kernels: A General Mechanism For Kernel Specialization in Existing Operating Systems&lt;/h1&gt;
&lt;h2 id=&quot;application-selectable-kernel-specializations-by-chick-et-al&quot;&gt;Application selectable kernel specializations by Chick et al.&lt;/h2&gt;

&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;Chick et al start their paper by noting that existing operating system share
one single kernel &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; section between all running tasks, and that this fact
contradicts recent research which has proved from time to time that profile
guided optimizations are beneficial. Their solution involves remapping the
running kernel’s page-tables on context switches and expose to user-space the
ability to choose which “shadow kernel” to bind its process to. The authors
have implemented their prototype using the Xen hypervisor and argue that, thus,
it can be extended to any operating system that runs on Xen.&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;The authors argue that in a traditionally monolithic operating systems, system
calls are fast because they don’t require swapping page tables and flushing the
TLB’s caches. However, the disadvantage of such system is the fact that
per-process optimization of the kernel is now impossible. To fix the
discrepancy between relevant research on profile guided optimizations and the
apparent lack of embracing it, they introduce “shadow kernels”, a per-process
optimization mechanism of the kernel’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; section.&lt;/p&gt;

&lt;h3 id=&quot;motivation&quot;&gt;Motivation&lt;/h3&gt;

&lt;p&gt;The authors of this paper highlight three benefits of “shadow kernels” that
have motivated them.&lt;/p&gt;

&lt;p&gt;Firstly, the already mentioned recent research into profile-guided
optimization. One of the unsolved issues of such optimization is that it must
be based on a representative workload. They argue that, &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Shadow kernels allow
applications executing on the same machine to each execute with their own
kernel that is optimized with profile-guided optimization specific to that
program.&lt;/code&gt;&lt;/em&gt; And thus, the problem about representative workload is solved,
because you presumably know the profile of your own program and you no longer
need to care about other processes running on the same machine.&lt;/p&gt;

&lt;p&gt;Secondly, scoping probes. It is well known that Linux has multiple
instrumentation primitives, for instance Kprobes and DTrace. The authors argue
that when one process may want to be instrumented, &lt;em&gt;every&lt;/em&gt; other process in the
system is also impacted by the overhead of installing the primitive. In
contemporary operating systems it is simply impossible to restrict the scope of
a probe to a single, or a group of, process(es). Shadow kernels again present a
solution here by replacing the pages of the affected process’ kernel &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt;
region.&lt;/p&gt;

&lt;p&gt;Finally, the third factor that has motivated the authors is about overall
optimization of the kernel and its fast paths. They argue that while security
checks are in the kernel there is a strong case for trusted processes, which do
not necessarily need the protections that are in place and in those cases the
additional checks are a bottleneck` to their performance. With shadow kernels,
it is possible to remove security checks from the address space of one process
while leaving them intact in all other processes.&lt;/p&gt;

&lt;h3 id=&quot;design&quot;&gt;Design&lt;/h3&gt;

&lt;p&gt;The most important parts about the shadow kernel design can be nicely summed in
the authors’ own words: &lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;An application can spawn a new shadow kernel through
a call to a kernel module. This creates a copy-on-write version of the
currently running kernel, which is mapped into the memory of the process that
created it. As a process registers probes, the specialization mechanism makes
modifications to the kernel’s instruction stream. Due to the use of
copy-on-write, every page that is modified is then physically copied, leaving
the original kernel text un-touched.&lt;/code&gt;&lt;/em&gt; Modified functions are replaced using
standard mechanisms of either rewriting the entire block if the “replacee” is
shorter or the same length or using an unconditional jump that is easy to
branch predict.&lt;/p&gt;

&lt;center&gt;


&lt;figure&gt;
&lt;img src=&quot;/assets/posts/2017-08-20-paper-review-shadow-kernels/overview.png&quot; /&gt;
&lt;figcaption&gt;Overview of the design of shadow kernels&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/center&gt;

&lt;p&gt;The above figure gives us a little overview on the actual architectural details
of this novel technique.&lt;/p&gt;

&lt;p&gt;One of the more interesting problems with this approach is dealing with kernel
code that is not bound to a single process (think, kworkers, interrupts and
schedulers). The authors mention that is difficult to just go ahead and remap
the pages because other processes may want to augment the same page in a
different way. The solution they propose is giving up isolation and using the
code of a “union” shadow kernel that contains all of the probes.&lt;/p&gt;

&lt;h3 id=&quot;implementation&quot;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;Probably one of the most fascinating I’ve read in this paper is the fact their
entire implementation is 250 lines of code entirely implemented as a Linux
kernel module. Pretty much of the implementation is specific to the Linux
kernel thus, and I don’t think describing it here would be of much value,
rather anyone interested can read the paper and find more detail about how the
implementation adheres to the Design outlined above.&lt;/p&gt;

&lt;h3 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h3&gt;

&lt;p&gt;Furthering motivation, the authors show that probing the most popular kernel
function called across all CPUs reduces single thread performance by &lt;strong&gt;30%&lt;/strong&gt;,
and it keeps worsening if you probe the top three functions to &lt;strong&gt;50%&lt;/strong&gt;. They
tested their setup monitoring the performance of memcached and installing
probes in an unrelated process. From this result, it is clear that some
technique to solve this, is worthwhile.&lt;/p&gt;</content><author><name>Levente Kurusa</name></author><summary type="html">Shadow Kernels: A General Mechanism For Kernel Specialization in Existing Operating Systems Application selectable kernel specializations by Chick et al. Abstract Chick et al start their paper by noting that existing operating system share one single kernel .text section between all running tasks, and that this fact contradicts recent research which has proved from time to time that profile guided optimizations are beneficial. Their solution involves remapping the running kernel’s page-tables on context switches and expose to user-space the ability to choose which “shadow kernel” to bind its process to. The authors have implemented their prototype using the Xen hypervisor and argue that, thus, it can be extended to any operating system that runs on Xen.</summary></entry><entry><title type="html">Pointer indirection: A journey into infinity</title><link href="http://kernelstuff.org/post/pointer/2017/06/09/pointer-indirection.html" rel="alternate" type="text/html" title="Pointer indirection: A journey into infinity" /><published>2017-06-09T06:06:10+02:00</published><updated>2017-06-09T06:06:10+02:00</updated><id>http://kernelstuff.org/post/pointer/2017/06/09/pointer-indirection</id><content type="html" xml:base="http://kernelstuff.org/post/pointer/2017/06/09/pointer-indirection.html">&lt;p&gt;A few months ago my colleague at Imperial College London showed me a piece of
code that was part of the mandatory second-year course on Operating Systems.
The code had around 5 levels of pointer indirection. That was unusual and it
got me thinking. What is absolute maximum of indirection of pointers that
compilers can handle?&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;But wait! What do we mean by “pointer indirection” ? Perhaps, this is best
explained by actual code:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this simple &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; code we can see that the pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; has level &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; of
indirection. It directly points to the variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;. However, the
following sample has level &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; of indirection:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; here now points to another pointer that finally points to our
&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;. It &lt;em&gt;indirectly&lt;/em&gt; points to our value, and thus has an indirection level
of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;limits&quot;&gt;Limits&lt;/h3&gt;

&lt;p&gt;Let’s have a look at the standard first. The [C standard] specifies that an
implementation shall be able to compile and execute a source with  “12 pointer,
[…] declarators […] modifying a […] type in a declaration“. That is, the
C standard requires implementations to support at least 12 levels of
indirection, but the upper bound is left to the implementations themselves.
They can decide to only support 13 levels, or they can decide to support up to
2.147 billion levels of indirection if they so choose. The usefulness of the
latter, or even of the former, is left as an exercise to the reader.&lt;/p&gt;

&lt;h3 id=&quot;testing&quot;&gt;Testing&lt;/h3&gt;
&lt;p&gt;The first compiler I tested was the default &lt;code class=&quot;highlighter-rouge&quot;&gt;cc&lt;/code&gt; that is running on my Late
2016 MacBook Pro, which turns out to be:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cc --version
 Apple LLVM version 8.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;clang-802.0.42&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 Target: x86_64-apple-darwin16.5.0
 Thread model: posix
 InstalledDir: /Library/Developer/CommandLineTools/usr/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;… which is a simple Clang.
An other compiler that I will be using is &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc-6&lt;/code&gt; from Homebrew, that is:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gcc-6 --version
 gcc-6 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Homebrew gcc 6.2.0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 6.2.0
 Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2016 Free Software Foundation, Inc.
 This is free software; see the &lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;copying conditions.  There is NO
 warranty; not even &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;.. which as expected is GCC 6.2.0&lt;/p&gt;

&lt;p&gt;So, how do you actually test this? I quickly cooked together a simple (and
extremely naive) implementation that helps:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USAGE: %s INDIRECTION&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atoi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Indirection: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;run.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;w+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error creating &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;run.c&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;int main(int argc, char **argv) {&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;    int i0 = %d;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;int &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;i%d = &amp;amp;i%d;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;    printf(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;, &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;i%d);&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Arguably not well optimized or anything, but it does the job of generating C
source code that contains the given number of indirection. In short, it
generates files of the sort:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;***&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;***&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In this example the indirection level is &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, let’s test this previous snippet with the two compilers:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cc run.c 
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./a.out
4
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gcc-6 run.c
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./a.out
4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;As expected by the standard, this is supported. Let’s try with a larger number,
say 1000, but this time also check how long each compilation takes.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./generator 1000
Indirection: 1000
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;cc run.c -o run-cc-1000
0.18 real         0.13 user         0.03 sys
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;gcc-6 run.c -o run-gcc6-1000
1.88 real         1.52 user         0.26 sys
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./run-cc-1000
1000
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./run-gcc6-1000
1000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As we can see, both have compiled and executed successfully, but interestingly
GCC 6.2.0 took a lot longer than the Clang compiler. Let’s continue on and test
at indirection level 10000:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./generator 10000
Indirection: 10000
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cc run.c -o run-cc-10000
cc run.c -o run-cc-10000
 clang: error: unable to execute &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;: Illegal instruction: 4
 clang: error: clang frontend &lt;span class=&quot;nb&quot;&gt;command &lt;/span&gt;failed due to signal &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use -v to see invocation&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 Apple LLVM version 8.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;clang-802.0.42&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 Target: x86_64-apple-darwin16.5.0
 Thread model: posix
 InstalledDir: /Library/Developer/CommandLineTools/usr/bin
 clang: note: diagnostic msg: PLEASE submit a bug report to http://developer.apple.com/bugreporter/ and include the crash backtrace, preprocessed &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;, and associated run script.
 clang: note: diagnostic msg:
 &lt;span class=&quot;k&quot;&gt;********************&lt;/span&gt;
 
 PLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:
 Preprocessed &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; and associated run script&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; are located at:
 clang: note: diagnostic msg: /var/folders/25/5ggbk47j2038sjfz9m6ckt1h0000gn/T/run-71b506.c
 clang: note: diagnostic msg: /var/folders/25/5ggbk47j2038sjfz9m6ckt1h0000gn/T/run-71b506.sh
 clang: note: diagnostic msg: /var/folders/25/5ggbk47j2038sjfz9m6ckt1h0000gn/T/run-71b506.crash
 clang: note: diagnostic msg:
 
 &lt;span class=&quot;k&quot;&gt;********************&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;What just happened. Looks like clang crashed on an illegal instruction (SIGILL).
However, after looking at the crash trace and building upstream, the real source
of the bug is that the code causes a stack overflow. Clang (the LLVM frontend)
crashes in &lt;code class=&quot;highlighter-rouge&quot;&gt;clang/lib/Parse/ParseDecl.cpp&lt;/code&gt; in function &lt;code class=&quot;highlighter-rouge&quot;&gt;ParseDeclaratorInternal&lt;/code&gt;.
The function seems to call itself recursively to parse the &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; tokens, and
the stack is too small. Too bad. Eventually, I should/will file a bug report.&lt;/p&gt;

&lt;p&gt;GCC on the other hand managed to compile it, but it took an awful lot of time:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;gcc-6 run.c -o run-gcc6-10000
2419.57 real      2152.83 user        35.52 sys
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Woah! That is indeed a lot of time, around 40 minutes.
Let’s use binary search and find what is the pointer indirection that clang can
handle. We know it worked for &lt;code class=&quot;highlighter-rouge&quot;&gt;n0&lt;/code&gt; = 1,000 and it failed at &lt;code class=&quot;highlighter-rouge&quot;&gt;nF&lt;/code&gt; = 10,000.
Naturally, the next step is to test at &lt;code class=&quot;highlighter-rouge&quot;&gt;n1&lt;/code&gt; = 4,500. Generating the file with
4,500 levels of indirection and then firing up clang yields the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang: error: unable to execute command: Illegal instruction: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next step, &lt;code class=&quot;highlighter-rouge&quot;&gt;n2&lt;/code&gt; = 2,750, yielding an empty string. Wow, the compilation
succeeded! Now we know the fault happens between 2,750 and 4,500 levels of
indirection. Next try is at &lt;code class=&quot;highlighter-rouge&quot;&gt;n3&lt;/code&gt; = 3,625. Once again, we get an empty string,
compilation succeeded and we get the expected result when ran. Next step, &lt;code class=&quot;highlighter-rouge&quot;&gt;n4&lt;/code&gt;
= 4,062. After bisecting, I got the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;nf&lt;/code&gt; = 3,872. clang (at least the
version my MacBook Pro is running) seems to support &lt;strong&gt;up to 3,872 levels of
pointer indirection&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Interesting? Not sure. Useful? Hopefully not. Fun?
Absolutely.&lt;/p&gt;</content><author><name>Levente Kurusa</name></author><summary type="html">A few months ago my colleague at Imperial College London showed me a piece of code that was part of the mandatory second-year course on Operating Systems. The code had around 5 levels of pointer indirection. That was unusual and it got me thinking. What is absolute maximum of indirection of pointers that compilers can handle?</summary></entry><entry><title type="html">waccOS - Part I</title><link href="http://kernelstuff.org/kernel/waccos/2017/03/05/waccOS-intro.html" rel="alternate" type="text/html" title="waccOS - Part I" /><published>2017-03-05T13:00:00+01:00</published><updated>2017-03-05T13:00:00+01:00</updated><id>http://kernelstuff.org/kernel/waccos/2017/03/05/waccOS-intro</id><content type="html" xml:base="http://kernelstuff.org/kernel/waccos/2017/03/05/waccOS-intro.html">&lt;p&gt;Imperial College’s Computer Science undergraduates will be already familiar
with the language &lt;em&gt;WACC&lt;/em&gt;. It is a While-like language that is part of the
mandatory 2nd-year Compilers course and the Integrated Laboratory coursework.
Basically, the goal is to create a compiler for the language &lt;em&gt;WACC&lt;/em&gt; (for which
you are given a specification) in your language of choice in 4 weeks. After the
initial 4 weeks, you have 2 extra weeks to implement some extensions of your
own choice. Some suggested extensions range from adding fully recursive pair
types, dynamic typing, all the way to garbage collection and even static
analysis for dynamic types. However, there was one which we spotted fairly
early on. &lt;strong&gt;Write an operating system.&lt;/strong&gt;&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;waccOS % cat /etc/release
waccOS 1.0
Kernel compiled via: WACC-04-HASKELL
AUTHORS: Levente Kurusa
         Atanas Gospodinov
         Daniel Zvara
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To get a feel of the original (I say original, because obviously, we extended
it just enough to support an operating system) &lt;em&gt;WACC&lt;/em&gt; language, here is a
Fibonacci sequence implementation:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin
int fibonacci(int n) is
  if n &amp;lt;= 1 then
    return n
  else
    skip
  fi ;
  int f1 = call fibonacci(n - 1) ;
  int f2 = call fibonacci(n - 2) ;
  return f1 + f2
end

println &quot;This calculates the nth fibonacci number recursively.&quot; ;
print &quot;Please enter n (should not be too large): &quot; ;
int n = 0;
read n ;
print &quot;The input n is &quot; ;
println n ;
print &quot;The nth fibonacci number is &quot; ;
int result = call fibonacci(n) ;
println  result
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As one can see, the language uses &lt;code class=&quot;highlighter-rouge&quot;&gt;begin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;end &lt;/code&gt; keywords instead of curly
brackets and also has no notion of &lt;code class=&quot;highlighter-rouge&quot;&gt; void&lt;/code&gt;, even requiring a special keyword
for calling functions, &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;. All function return values have to be assigned
to a local variable and the language has no notion of global variables. &lt;em&gt;WACC&lt;/em&gt;
uses an implicit main function, sort of like what Python can do. It also uses
built-in functions like &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; to be able to address the outside
world. The language has been exclusively designed to be fairly easy to write a
compiler for. But not for low-level systems-level programming.&lt;/p&gt;

&lt;p&gt;So, what did my team do? We built a fairly simple operating system for the
(in)famous &lt;em&gt;Raspberry Pi ARM&lt;/em&gt; board. Given the freedom of writing our own
compiler and implementing any extensions for it, we decided we will implement
extensions that are low-level enough to support an operating system kernel. The
result? A C-like &lt;code class=&quot;highlighter-rouge&quot;&gt;WACC&lt;/code&gt; with all the famous features you can guess, like
pointers, structures, and even inline assembly. This how some our code looks
like now:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int test_frame(uint32 a) is
  int f = a / 0x1000;
  int i = INDEX_BIT(f);
  int o = OFFSET_BIT(f);
  return (*(frames+i) &amp;amp; (1 &amp;lt;&amp;lt; o));
end

bool check_n_frames_free(int start, int n) is
  for (uint32 j = 0; j &amp;lt; n; j++) do
    if (test_frame(start + 0x1000 * j) != 0) then
      return false;
    end
  end

  return true;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Before diving into the operating system we wrote, let’s talk about how we built
the compiler. We decided that the best language we can choose for writing our
compiler is Haskell, because of its excellent support for parsing and a
plethora of wonderful tools (that is, mostly type classes) to help us create
the compiler. Originally, people were supposed to be using the stack for every
local variable, however, we implemented a register allocator based on the
&lt;a href=&quot;http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf&quot;&gt;Linear Scan Register
Allocation&lt;/a&gt;
algorithm devised by MIT and IBM computer scientists back in the 1990s. This
allowed us to avoid overusing the stack and made our resulting assembly code
just a bit more deterministic.&lt;/p&gt;

&lt;p&gt;One of the first things we implemented in &lt;em&gt;waccOS&lt;/em&gt; is a method to communicate
via the serial port so that we could save the time that we would otherwise need
to implement a full-blown terminal emulator with font rendering and all the
escape codes. Instead, we opted for implementing a driver for the &lt;em&gt;UART&lt;/em&gt; that
exists as GPIO #14 and #15 on the board. However,  this was not as easy as it
sounds. We’ve hit two major obstacles, including a quite severe one. We
followed the specification of the &lt;em&gt;UART&lt;/em&gt; closely and even tried copy/pasting
tutorial code, but for some reason, the &lt;em&gt;UART&lt;/em&gt; console on my Linux box was not
displaying anything. Maybe it’s the &lt;em&gt;FTDI&lt;/em&gt; chip we use? Maybe the cable is
damaged? Maybe the &lt;em&gt;Raspberry PI&lt;/em&gt; is faulty? After countless days of debugging
without success, it struck me. Maybe, we should try reverting the boot firmware
to an older version! We reverted to a May 2016 version and surprise, it worked!
I’ll eventually write a separate blog post on this issue because the way we
debugged this issue and all those contradicting results that came in were
really amusing in retrospect.&lt;/p&gt;

&lt;p&gt;Second issue also constitutes a blog post. This time we spent a fair amount of
time figuring out that we needed to have our strings aligned to a 16-byte
boundary for our &lt;em&gt;UART&lt;/em&gt; code to work. This taught us the lesson that ARM
unaligned/aligned access is a wonderful piece and is definitely worth a blog
post. For example, while on recent ARM processors most instructions support
unaligned access, &lt;code class=&quot;highlighter-rouge&quot;&gt;STM&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;LDM&lt;/code&gt; (Store Multiple and Load Multiple,
respectively) do not, in fact, they result in undefined behavior! (Which
sometimes confused us, because it seemed to work every once in a while)&lt;/p&gt;

&lt;p&gt;Anyway, after we got the &lt;em&gt;UART&lt;/em&gt; working, we decided that we should write a very
simple, but interactive shell. This shell later formed a critical part as we
could both test our compiler’s new features and &lt;em&gt;waccOS&lt;/em&gt;’s new features as well
with ease. For example, here is us testing the &lt;em&gt;ps&lt;/em&gt; functionality which
basically tests the scheduler:&lt;/p&gt;

&lt;center&gt;


&lt;figure&gt;
&lt;img src=&quot;/assets/posts/2017-03-05-waccos-part-i/sched_test.png&quot; /&gt;
&lt;figcaption&gt;the ps command in the interactive kernel shell&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/center&gt;

&lt;p&gt;Or here is us debugging the &lt;em&gt;ext2&lt;/em&gt; driver:&lt;/p&gt;

&lt;center&gt;


&lt;figure&gt;
&lt;img src=&quot;/assets/posts/2017-03-05-waccos-part-i/ext2_driver.png&quot; /&gt;
&lt;figcaption&gt;ext2 driver outputting debug information about the volume&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/center&gt;

&lt;p&gt;Overall, this project has been massive fun. I plan to go over each important
feature of our operating system kernel and write a blog post on how they’ve
been built and the challenges we’ve faced. In the next part of this series I
will talk a little about ARM’s way of dealing with unaligned access since this
has proved to be a really important knowledge that anyone planning to do
bare-metal programming for ARM has to know.&lt;/p&gt;

&lt;p&gt;*PS: The source code for the compiler is sadly not publicly available due to academic
integrity, however if you send me a message, I’ll send you a zip. Meanwhile, the
OS is available &lt;a href=&quot;https://github.com/levex/wacc-os&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</content><author><name>Levente Kurusa</name></author><summary type="html">Imperial College’s Computer Science undergraduates will be already familiar with the language WACC. It is a While-like language that is part of the mandatory 2nd-year Compilers course and the Integrated Laboratory coursework. Basically, the goal is to create a compiler for the language WACC (for which you are given a specification) in your language of choice in 4 weeks. After the initial 4 weeks, you have 2 extra weeks to implement some extensions of your own choice. Some suggested extensions range from adding fully recursive pair types, dynamic typing, all the way to garbage collection and even static analysis for dynamic types. However, there was one which we spotted fairly early on. Write an operating system.</summary></entry><entry><title type="html">Pagefault decoder</title><link href="http://kernelstuff.org/kernel/calculators/2017/03/05/pagefault_decoder.html" rel="alternate" type="text/html" title="Pagefault decoder" /><published>2017-03-05T13:00:00+01:00</published><updated>2017-03-05T13:00:00+01:00</updated><id>http://kernelstuff.org/kernel/calculators/2017/03/05/pagefault_decoder</id><content type="html" xml:base="http://kernelstuff.org/kernel/calculators/2017/03/05/pagefault_decoder.html">&lt;p&gt;Many times over the past few years I’ve encountered Page Faults that due to
the nature of the environment, were only displayed in hexadecimal format. To
make these error codes human-readable, I’ve made a quick demo to let me do just
that.&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;Enter the error code, here, either in hexadecimal or in decimal notation and
the readable-string will be shown:&lt;/p&gt;

&lt;script&gt;
function solve() {
	var val = parseInt(document.getElementById(&quot;code&quot;).value);

	var not_present = !(val &amp; 1 != 0);
	var write = val &amp; 2 != 0;
	var user = !(val &amp; 4 != 0);
	var ifetch = (val &amp; 16 != 0);
	result = &quot;&lt;br /&gt; &quot; + (not_present ? &quot;not present&quot; : &quot;rights violation&quot;) +
		&quot; error occured while &quot; + (write ? &quot;writing to&quot; : &quot;reading from&quot;) +
		&quot; page in &quot; + (user ? &quot;user&quot; : &quot;kernel&quot;) + 
		&quot; context&quot; + (ifetch ? &quot; (during instruction fetch)&quot; : &quot;&quot;);

	document.getElementById(&quot;solution&quot;).innerHTML = result;
}
&lt;/script&gt;

&lt;p&gt;Error code: &lt;input type=&quot;text&quot; id=&quot;code&quot; /&gt;&lt;br /&gt;
  &lt;input type=&quot;button&quot; onclick=&quot;solve()&quot; value=&quot;Submit&quot; /&gt;
  &lt;span id=&quot;solution&quot;&gt;&lt;/span&gt;&lt;/p&gt;</content><author><name>Levente Kurusa</name></author><summary type="html">Many times over the past few years I’ve encountered Page Faults that due to the nature of the environment, were only displayed in hexadecimal format. To make these error codes human-readable, I’ve made a quick demo to let me do just that.</summary></entry><entry><title type="html">First post!</title><link href="http://kernelstuff.org/post/hello/2017/02/27/welcome-to-jekyll.html" rel="alternate" type="text/html" title="First post!" /><published>2017-02-27T15:06:10+01:00</published><updated>2017-02-27T15:06:10+01:00</updated><id>http://kernelstuff.org/post/hello/2017/02/27/welcome-to-jekyll</id><content type="html" xml:base="http://kernelstuff.org/post/hello/2017/02/27/welcome-to-jekyll.html">&lt;p&gt;Hello, world, welcome to this blog.&lt;/p&gt;

&lt;!-- MORE --&gt;

&lt;p&gt;This blog is written by Levente Kurusa, a student at Imperial College London.&lt;/p&gt;

&lt;p&gt;Check out the About page if you want to contact me or have feedback about an
article.&lt;/p&gt;

&lt;p&gt;Cheers,&lt;/p&gt;

&lt;p&gt;Lev&lt;/p&gt;</content><author><name>Levente Kurusa</name></author><summary type="html">Hello, world, welcome to this blog.</summary></entry></feed>